from audioop import maxpp
import requests
from datetime import datetime as dt
from datetime import timedelta
import numpy as np
import matplotlib.pyplot as plt
import pandas as pd
from fmiopendata.wfs import download_stored_query
from entsoe import EntsoePandasClient

"""
This library contains the most critical functions for forecasting wind production,
API accesses etc.
"""

FINGRID_API_KEY = "i7AbaUazlB7XPaVkbrGNh7G1SEhIgDZ68pSt2EaT"
ENTSOE_API_KEY = "32315fb3-eac5-48b3-a08b-b7514c875395"

def power_curve(wind_speed, max_power=4200):
    """
    uses a standard wind turbine power curve to approximate the power output of a single turbine 
    given a wind speed as an input.

    Parameters
    ----------
    wind_speed : int
        the wind speed used for approximation
    max_power : int, optional
        The max power output of the turbine (default is 4200 kWh)

    Returns
    -------
    float 
        estimated power output of the turbine
    """
    if wind_speed < 3 or wind_speed > 22.5:
        return 0
    elif wind_speed >= 11:
        return max_power
    else:
        return max_power*0.5*np.sin(wind_speed*0.4 + np.pi*1.1) +max_power/2

def get_datetimes(start_time=dt.now(), hours=48):
    """
    A helper method that returns a list of the next hours as datetime objects.
    Used for accessing FMI APIs return objects that are mapped by the beginning hour.
    Maximum lenght of a sequence is 50, this is because of the limitations in FMI API.

    Parameters
    ----------
    start_time: datetime.datetime, optional
        the starting hour of the list (default is now)
    hours: int, optional
        the number of hours to include in the return list (default is 48)

    Returns
    -------
    list 
        a list of datetime objects.
    """
    if hours > 50:
        return []
    
    start_time = start_time.replace(minute=0, second=0, microsecond=0)
    dts = []
    for h in range(hours):
        t = start_time + timedelta(hours=h)
        dts.append(t)
    return dts

def get_fingrid_forecast(start_time=dt.now(), hours=36):
    """
    Retrieves a list of Finland's total wind power generation forecasts from Findgrid's API.
    This forecast is for the next 36 hours and updates hourly. The unit is MWh/h.
    Variable ID 245 corresponds with the total wind power generation forecast in the API.

    Parameters
    ----------
    start_time: datetime.datetime, optional
        the starting hour of the list (default is now)
    hours: int, optional
        the number of hours to include in the return object (default is 36)

    Returns
    -------
    list 
        a list of wind production predictions from Fingrid's API
    """
    if hours > 36:
        print("HOURS TOO LARGE, MAX FORECAST LENGTH IS 36")
        return []

    BASE_URL = "https://api.fingrid.fi"
    VARIABLE_ID = 245 # MWh/h
    URL = (f'{BASE_URL}/v1/variable/{VARIABLE_ID}/events/json')

    end_time = start_time + timedelta(hours=hours)
    formatted_start_time = start_time.strftime("%Y-%m-%dT%H")
    formatted_end_time = end_time.strftime("%Y-%m-%dT%H")

    URL = f'{URL}?start_time={formatted_start_time}%3A00%3A00Z&end_time={formatted_end_time}%3A00%3A00Z'

    headers={'accept': 'application/json', 'x-api-key':FINGRID_API_KEY}

    # sending get request and saving the response as response object
    r = requests.get(url = URL, headers = headers)

    # extracting data in json format
    data = r.json()
    fingrid_values = [i['value'] for i in data]
    return fingrid_values

def get_fmi_surface_forecast(place, start_time=dt.now()):
    """
    Surface level forecasts from FMI using the endpoint: fmi::forecast::harmonie::surface::point::multipointcoverage.
    Instructions for using the API: https://github.com/pnuu/fmiopendata

    Parameters
    ----------
    place: string
        name of the weather station or location to fetch the forecasts for. The API endpoint also supports long/lat coordinates but no method for using those exists as of yet.
    start_time: datetime.datetime, optional
        the starting hour of the list (default is now)
    
    Returns
    -------
    Dictionary
        a dictionary containing all of the weather data generated by FMI.
    """
    start_time = start_time.replace(minute=0, second=0, microsecond=0)
    # Convert times to properly formatted strings
    start_time = start_time.isoformat(timespec="seconds") + "Z"

    # default timeframe is 50h if no endtime is specified
    obs = download_stored_query("fmi::forecast::harmonie::surface::point::multipointcoverage",
                                    args=[f"starttime={start_time}",
                                            #"endtime=2022-08-04T23:00:00Z",
                                            f"place={place}"])
    return obs

def get_fmi_forecast_at_height(place, start_time=dt.now(), height=100):
    """
    Forecasts from FMI using the endpoint: fmi::forecast::harmonie::hybrid::point::multipointcoverage.
    Instructions for using the API: https://github.com/pnuu/fmiopendata

    Parameters
    ----------
    place: string
        name of the weather station or location to fetch the forecasts for. The API endpoint also supports long/lat coordinates but no method for using those exists as of yet.
    start_time: datetime.datetime, optional
        the starting hour of the list (default is now)
    height: int, optional
        The height for which to get the forecasts (default is 100 meters)
    
    Returns
    -------
    Dictionary
        a dictionary containing all of the weather data generated by FMI.
    """
    start_time = start_time.replace(minute=0, second=0, microsecond=0)
    # Convert times to properly formatted strings
    start_time = start_time.isoformat(timespec="seconds") + "Z"

    # default timeframe is 50h if no endtime is specified
    obs = download_stored_query("fmi::forecast::harmonie::hybrid::point::multipointcoverage",
                                    args=[f"starttime={start_time}",
                                            #"endtime=2022-08-04T23:00:00Z",
                                            f"place={place}",
                                            f"height={height}"])
    return obs

def get_power_forecast(place, hours=48, start_time=dt.now()):
    """
    This method fetches the forecast for a given place and timeframe and appends the power prediction to the result.
    The power prediction is calculated using the power_curve method in this class.
    The forecast uses the API endpoint: fmi::forecast::harmonie::hybrid::point::multipointcoverage.

    Parameters
    ----------
    place: string
        name of the weather station or location to fetch the forecasts for. The API endpoint also supports long/lat coordinates but no method for using those exists as of yet.
    hours: int
        The number of hours included in the forecast
    start_time: datetime.datetime, optional
        the starting hour of the list (default is now)
    
    Returns
    -------
    Dictionary
        a dictionary containing all of the weather data generated by FMI and added power generation forecast.
    """
    obs = get_fmi_forecast_at_height(place, start_time)
    dts = get_datetimes(start_time, hours)

    for t in dts:
        wind_speed = obs.data[t][place]["Wind speed"]["value"]
        power = power_curve(wind_speed)
        obs.data[t][place]["Power"] = {"value": power, "units": "kWh"}
    return obs

def get_power_list(place, hours=48, start_time=dt.now()):
    """
    Returns a list of hourly power forecasts for a given place and timeframe.
    The power prediction is calculated using the power_curve method in this class.
    The forecast uses the API endpoint: fmi::forecast::harmonie::hybrid::point::multipointcoverage.

    Parameters
    ----------
    place: string
        name of the weather station or location to fetch the forecasts for. The API endpoint also supports long/lat coordinates but no method for using those exists as of yet.
    hours: int
        The number of hours included in the forecast
    start_time: datetime.datetime, optional
        the starting hour of the list (default is now)
    
    Returns
    -------
    list
        a list containing the power output predictions
    """
    forecast = get_power_forecast(place, hours, start_time)
    dts = get_datetimes(start_time, hours)
    power_list = []

    for t in dts:
        p = forecast.data[t][place]["Power"]["value"]
        power_list.append(p)
    return power_list

def mean_power_forecast(places, hours=48, start_time=dt.now()):
    """
    Calculate a mean power production prediction for the places given in places param.
    
    The method uses the API endpoint: fmi::forecast::harmonie::hybrid::point::multipointcoverage.

    Parameters
    ----------
    places: list of strings
        names of the weather station or location to fetch the forecasts for.
    hours: int
        The number of hours included in the forecast
    start_time: datetime.datetime, optional
        the starting hour of the list (default is now)
    
    Returns
    -------
    Numpy array
        An array containing the mean of the predicted output power for each place in the given list
    """
    forecasts = np.zeros(shape=(hours, len(places)))
    row_idx = 0
    for place in places:
        power_list = get_power_list(place, hours, start_time)
        forecasts[:,row_idx] = power_list
        row_idx +=1

    return np.mean(forecasts, axis=1)

def print_wind_speeds(place, hours=48, start_time=dt.now()):
    """
    Print FMI data for debugging.
    
    The method uses the API endpoint: fmi::forecast::harmonie::hybrid::point::multipointcoverage.

    Parameters
    ----------
    place: string
        name of the weather station or location to fetch the forecasts for.
    hours: int
        The number of hours included in the forecast
    start_time: datetime.datetime, optional
        the starting hour of the list (default is now)
    
    Returns
    -------
    No return value
    """
    obs = get_fmi_forecast_at_height(place, start_time)
    dts = get_datetimes(start_time, hours)
    i = 0
    for t in dts:
        i += 1
        s = obs.data[t][place]["Wind speed"]
        print(t)
        print(s)
        print(f"----------{i}-------------")

def is_cheap(power_list, capacity_lim=0.6, max_cap=4200):
    """
    Returns a list of booleans determining the pricezone for the given list of power outputs.

    Parameters
    ----------
    power_list: list[int]
        List of power predictions.
    capacity_lim: float, optional
        The threshold capacity that determines when the pricezone will change.
        If production is over the threshold, the price is cheap (default is 0.6).
    max_cap: int, optional
        Maximum power output of the turbine for which the predictions are for (default is 4200).
    
    Returns
    -------
    pricezones_ list[boolean]
        A list of booleans determining the pricezone of the given hour.
    """
    pricezones = []
    for p in power_list:
        if p > max_cap*capacity_lim:
            pricezones.append(True)
        else:
            pricezones.append(False)
    return pricezones

def get_customer_pricezones(power_list, capacity_lim=0.6, max_cap=4200, low_price=0.04, high_price=0.35):
    """
    Returns a list of booleans determining the pricezones for the given list of power predictions.

    Parameters
    ----------
    power_list: list[int]
        List of power predictions.
    capacity_lim: float, optional
        The threshold capacity that determines when the pricezone will change.
        If production is over the threshold, the price is cheap (default is 0.6).
    max_cap: int, optional
        Maximum power output of the turbine for which the predictions are for (default is 4200).
    low_price: float, optional
        The price for the cheap hours in €/kWh (default is 0.04).
    high_price: float, optional
        The price for the expensive hours in €/kWh (default is 0.35).
    
    Returns
    -------
    prices list[float]
        A list of booleans determining the pricezone of the given hour. This is not the total
        price of the electricity, only the price per kWh.
    """
    prices = []
    cap_lim = capacity_lim * max_cap
    for p in power_list:
        if p > cap_lim:
            prices.append(low_price)
        else:
            prices.append(high_price)
    return prices

def get_customer_prices(power_list, capacity_lim=0.6, max_cap=4200, low_price=0.04, high_price=0.35):
    """
    Returns a list of booleans determining the prices for the given list of power predictions.

    Parameters
    ----------
    power_list: list[int]
        List of power predictions.
    capacity_lim: float, optional
        The threshold capacity that determines when the pricezone will change.
        If production is over the threshold, the price is cheap (default is 0.6).
    max_cap: int, optional
        Maximum power output of the turbine for which the predictions are for (default is 4200).
    low_price: float, optional
        The price for the cheap hours in €/kWh (default is 0.04).
    high_price: float, optional
        The price for the expensive hours in €/kWh (default is 0.35).
    
    Returns
    -------
    prices list[float]
        A list of booleans determining the pricezone of the given hour. This is the total
        price of the electricity per hour.
    """
    prices = []
    cap_lim = capacity_lim * max_cap
    for p in power_list:
        if p > cap_lim:
            prices.append(low_price * p)
        else:
            prices.append(high_price * p)
    return prices

def get_entsoe_day_ahead_prices(start_time=dt.now(), days=2, country_code='FI'):
    """
    Retrieves the day ahead prices for the given country code from ENTSOE's API.
    NOTE: Returns the values in the local timezone.

    Parameters
    ----------
    start_time: datetime.datetime, optional
        the starting hour of the list (default is now)
    hours: int, optional
        the number of hours to include in the return object (default is 24)
    country_code: string, optional
        Country code for which to get the prices

    Returns
    -------
    pandas series 
        a Pandas Series of day-ahead prices in the local timezone.
    """
    if start_time > dt.now():
        print("INVALID DATE RANGE")
        return pd.Series()

    client = EntsoePandasClient(api_key="32315fb3-eac5-48b3-a08b-b7514c875395")

    end_time = start_time + timedelta(days=days)
    start_str = start_time.strftime("%Y%m%d")
    end_str = end_time.strftime("%Y%m%d")
    #Accra time used here because it is GMT+0 always. All API responses are in CET/CEST.
    formatted_start_time = pd.Timestamp(start_str, tz='Africa/Accra')
    formatted_end_time = pd.Timestamp(end_str, tz='Africa/Accra')

    prices = client.query_day_ahead_prices(country_code, start=formatted_start_time,end=formatted_end_time)
    print(prices)
    return prices